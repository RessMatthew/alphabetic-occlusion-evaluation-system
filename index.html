<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>字母遮挡识别系统-实验</title>
    <link rel="stylesheet" href="./css/index.css">
    <style>
        [v-cloak]{
            display: none;
        }

    </style>
</head>

<body>
    <div class="progress"></div>
    <h4 class="task_intro">任务说明：请依据第一视感识别被遮挡的单个字母，并将猜测填入表单对应位置 </h4>
    <div id="container">
        <section class="svg">
            <p id="_time"></p>
            <canvas id="myCanvas" width="200" height="100" style="border:1px solid #d3d3d3;"></canvas>
        </section>

        <section class="form-content">
            <form id="order-form">
                <p v-cloak style="margin: 0;margin-top: 10px;color: #4060b2;font-weight: 500;">实验进度：{{activeCase+1}}/{{caseTotal}} </p>
                <div class="order">
                    <label class="font-weight">视感字母：</label>
                    <input id='inputLetter' maxlength="1" type="text" >
                </div>
                <div class="gap-container">
                    <label class="font-weight">确信程度：</label>
                    <div style="display:inline-block;">
                        <input type="radio" name="radio-option" value="1" id="option-1">
                        <label>1</label>
                    </div>
                    <div style="display:inline-block;">
                        <input type="radio" name="radio-option" value="2" id="option-2">
                        <label>2</label>
                    </div>
                    <div style="display:inline-block;">
                        <input type="radio" name="radio-option" value="3" id="option-3">
                        <label>3</label>
                    </div>
                    <div style="display:inline-block;">
                        <input type="radio" name="radio-option" value="4" id="option-4">
                        <label>4</label>
                    </div>
                    <div style="display:inline-block;">
                        <input type="radio" name="radio-option" value="5" id="option-5">
                        <label>5</label>
                    </div>
                </div>
            </form>
            <div id="next" class="button" @click="changeCase()">下一步</div>
        </section>
    </div>
    <p id="myp"></p>
</body>
<script src="js/vue.js"></script>
<script src="js/d3.min-v6.js"></script>
<script src="js/jquery-3.4.1.min.js"></script>
<script src="js/FileSaver.js"></script>
<script>
    let app = new Vue({
        el: "#container",
        data: {
            letter: null, //当前字母
            givenPercent: null, //当前重叠比例
            direction: null, //当前遮挡方向（1-8依次为：从最右逆时针）

            rect_width: null, //26字母中最大的宽度
            rect_height: null, //26字母中最大的高度

            caseList: [
                {
                    letter: 'a',
                    givenPercent: 0.1,
                    direction: 1,
                },
                {
                    letter: 'b',
                    givenPercent: 0.1,
                    direction: 3,
                },
                {
                    letter: 'b',
                    givenPercent: 0.2,
                    direction:5,
                },
                {
                    letter: 'f',
                    givenPercent: 0.7,
                    direction:6,
                },
                {
                    letter: 'z',
                    givenPercent: 0.6,
                    direction:2,
                },
            ], //案例列表
            caseTotal: null, //案例总数
            activeCase: 0, //当前案例的下标
            flash: null, //计时控件
            startTime: null, //案例开始时间
            endTime: null, //案例结束时间

            username: null, //姓名
            sex: null, //性别
            age: null, //年龄
            academic: null, //学历
            major: null, //专业
            dataStudy: null, //是否学过数据结构
            figureStudy: null, //是否学过图论
            analysisStudy: null, //是否做过图数据分析相关工作

            myCanvas_dom: null,
            inputLetter_dom: null,
            inputRadios_dom: null,
        },

        /**
         * 在组件挂载到 DOM 上后被调用
         */
        mounted: function () {
            // 注册全局键盘事件
            window.addEventListener("keydown", this.onKeyDown);

            this.myCanvas_dom = document.getElementById("myCanvas");
            this.inputElement = document.getElementById('inputLetter');
            this.inputElement.addEventListener("input", this.onInput);
            // this.time_dom = document.getElementById("_time")

            // 获取26字母中最大的宽度和高度
            [this.rect_width, this.rect_height] = this.getMaxWH()

            // 获取注册信息缓存
            this.username = localStorage.getItem('username');
            this.sex = localStorage.getItem('sex');
            this.age = localStorage.getItem('age');
            this.academic = localStorage.getItem('academic');
            this.major = localStorage.getItem('major');
            this.dataStudy = localStorage.getItem('dataStudy');
            this.figureStudy = localStorage.getItem('figureStudy');
            this.analysisStudy = localStorage.getItem('analysisStudy');

            if (this.username == null || this.major == null || this.analysisStudy == null) {
                // 无注册信息缓存
                window.location.href = 'signup.html' // 跳转到注册页面
            }
            else {
                // 有注册信息缓存
                this.caseList = this.getData(); // 获取案例列表
                // console.log(this.caseList)
                this.caseTotal = this.caseList.length // 获取案例总数

                let caseOrder = [] // 定义一个空数组用于存储已经选过的数字的下标
                let newCaseList = [] // 定义一个空数组用于存储生成的新数组
                for (let i = 0; i <= 25; i++) {
                    caseOrder.push(i);
                    newCaseList.push(this.caseList[(i)])
                }

                // 打乱前26个字母顺序
                function shuffle(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        let j = Math.floor(Math.random() * (i + 1)); // 生成 0 到 i 的随机整数
                        let temp = array[i];
                        array[i] = array[j];
                        array[j] = temp;
                    }
                    return array;
                }
                newCaseList = shuffle(newCaseList)

                // 循环直到新的列表中包含和原始列表相同数量的案例
                while (newCaseList.length < this.caseList.length) {
                    // 生成一个随机数字，范围为 0 到 caseList.length-1
                    // parseInt不能少
                    let num = parseInt(Math.random() * (this.caseList.length))

                    // 如果该数字的下标没有被选过，则将其存入 caseOrder 数组中，
                    // 并将该下标对应的元素加入 newCaseList 数组中。
                    if (caseOrder.indexOf(num) === -1) {
                        caseOrder.push(num)
                        newCaseList.push(this.caseList[num])
                    }
                }
                this.caseList = newCaseList // 将新的列表赋值给 this.caseList，完成打乱顺序的操作

                this.loadJson(); //加载案例文件
            }

        },

        methods: {
            /**
             * 添加下一步快捷键
             */
            onKeyDown: function (event) {
                if (event.key === "Enter") {
                    event.preventDefault(); // 阻止浏览器默认行为
                    this.changeCase()
                }else if(event.key === "1") {
                    event.preventDefault();
                    let radio = document.getElementById('option-1');
                    radio.checked = true;
                }else if(event.key === "2") {
                    event.preventDefault();
                    let radio = document.getElementById('option-2');
                    radio.checked = true;
                }else if(event.key === "3"){
                    event.preventDefault();
                    let radio = document.getElementById('option-3');
                    radio.checked = true;
                }else if(event.key === "4"){
                    event.preventDefault();
                    let radio = document.getElementById('option-4');
                    radio.checked = true;
                }else if(event.key === "5"){
                    event.preventDefault();
                    let radio = document.getElementById('option-5');
                    radio.checked = true;
                }
            },
            onInput: function () {
                // console.log(`Input element ${event.target.tagName} has value:`, event.target.value);
                this.endTime = Date.now();
                // console.log(this.endTime)
            },
            /**
             * 初始化加载案例文件
             */
            loadJson: function () {
                if(this.activeCase === 0)
                    alert('*******字母遮挡识别实验*******\n' + '1. 单个字母被不同程度遮挡；\n' + '2. 输入你的第一视感字母\n')

                this.inputElement.value = '';
                let radio = document.getElementById('option-1');
                radio.checked = true;
                radio.checked = false;

                this.givenPercent=this.caseList[this.activeCase]['givenPercent'];   // 当前重叠比例
                this.letter=this.caseList[this.activeCase]['letter'];   // 当前字母
                this.direction=this.caseList[this.activeCase]['direction']; //  当前遮挡方向

                // 创建了一个CanvasRenderingContext2D对象的实例
                let ctx = this.myCanvas_dom.getContext('2d', { willReadFrequently: true });
                // 清除画布左上角为原点、长宽分别为 200 像素和 100 像素的矩形区域
                ctx.clearRect(0,0,200,100);

                // 获取字母的宽度和高度
                let letter_metric = this.getTextMetric(this.letter);
                let [width,height] = [letter_metric[0],letter_metric[1]];
                let [start_x,start_y] = [ctx.canvas.width/2-width/2,ctx.canvas.height/2+height/2];
                let slope = height/width;

                // 绘制字母
                ctx.font = "16px Times New Roman";
                ctx.fillText(this.letter,start_x,start_y);

                // 绘制遮挡矩形
                let letter_pixel = this.get_global(ctx); // 获取已经被占用的像素坐标
                this.caseList[this.activeCase]['givenPercent'] = this.liner_rect_overlap(ctx, start_x, start_y, width, height,
                    this.rect_width, this.rect_height, this.direction, this.givenPercent, letter_pixel, slope)

                // document.getElementById("myp").innerHTML = "当前字母像素重叠比例：" +
                //     this.caseList[this.activeCase]['givenPercent'] + "字母-方向:" + this.letter + '-' + this.direction;

                this.initTimer(); //每个案例限时完成任务

                this.startTime = Date.now();

                // 聚焦输入框
                // let inputElements = document.querySelectorAll('.order input')
                // let inputElement = inputElements[0];
                // inputElement.focus();
            },
            /**
             * 每个案例限制完成时间，初始化计时器函数
             */
            initTimer: function () {
                let that = this;
                let timerCount = 5; //每个案例限制五秒时间

                this.flash = setInterval(function () { //每1秒刷新一次
                    document.getElementById("_time").innerHTML= '字母消失倒计时：'+ '<span style="color:red;">'+ timerCount + '<span/>' +'秒';
                    timerCount--;

                    //倒计时结束
                    if (timerCount === -1){
                        let ctx = that.myCanvas_dom.getContext('2d', { willReadFrequently: true });
                        ctx.clearRect(0,0,200,100); // 清除字母
                        clearInterval(that.flash);   // 关闭刷新
                    }
                }, 1000);
            },

            /**
             * 检查输入框中填写的信息是否符合要求
             */
            checkInputText: function () {
                if(!(/^[a-z]$/.test(this.inputElement.value))){ //判断是不是单个字母
                    return false
                }
                this.caseList[this.activeCase]['input'] = this.inputElement.value
                if(this.inputElement.value === this.caseList[this.activeCase]['letter']){
                    this.caseList[this.activeCase]['flag'] = 'true'
                }else{
                    this.caseList[this.activeCase]['flag'] = 'false'
                }
                return true
            },
            /**
             * 检查输入框中填写的信息是否符合要求
             */
            checkInputRadio: function () {
                let inputRadios = document.getElementsByName("radio-option")
                let confidence;
                for (let g = 0; g < inputRadios.length; g++) {
                    if (inputRadios[g].checked) {
                        confidence = inputRadios[g].value
                    }
                }
                if (confidence === undefined) {
                    return false
                }
                this.caseList[this.activeCase]['confidence'] =  parseInt(confidence)

                return true
            },
            /**
             * 用户点击下一步按钮后，更新画布中呈现的案例
             */
            changeCase: function () {
                let isCorrectOrder = this.checkInputText()
                let isCorrectGap = this.checkInputRadio() //检查radio框中填写的信息是否符合要求
                if (!isCorrectOrder || !isCorrectGap) {
                    alert('请输入单个小写字母且选择确信程度')
                    return;
                }
                let that = this;
                // if ((this.activeCase + 1) % 30 ===0 ){
                //     // this.endTime = Date.now();
                //     clearInterval(that.flash);   //关闭刷新
                //     this.caseList[this.activeCase]['time'] = (this.endTime - this.startTime)/1000;
                //     if (confirm("保存当前信息")) {
                //         //保存信息
                //         let casedata = this.caseList.slice(0, this.activeCase);
                //
                //         let localCaselist = []
                //         // 处理数据为csv的格式
                //         let csvString = ""
                //         csvString += "字母" + ',' + "遮挡方向" + ',' + "重叠比例" + ',' + "实验者视感" + ',' + "确信程度" + ','+ "耗时" + ',' + "是否正确"
                //         csvString += '\r\n'
                //         casedata.map(item => {
                //             let row = {
                //                 'letter': item.letter,
                //                 'direction': item.direction,
                //                 'givenPercent': item.givenPercent,
                //             }
                //             localCaselist.push(row) //caseList里面的案例顺序以答案为准
                //
                //             csvString += item.letter + ',' + item.direction + ',' + item.givenPercent + ',' + item.input + ',' + item.confidence + ',' + item.time + ',' + item.flag
                //             csvString += '\r\n'
                //         })
                //         //storage只能存储字符串的数据，对于JS中常用的数组或对象不能直接存储
                //         //可以通过JSON对象提供的parse和stringify将其他数据类型转化成字符串，再存储到storage中
                //         let str = JSON.stringify(localCaselist);
                //         localStorage.setItem("localCaselist", str);
                //
                //         // 保存为csv文件并添加下载按钮
                //         csvString = "data:application/csv," + encodeURIComponent(csvString);
                //         let link = document.createElement('a');
                //         link.href = csvString;
                //         //对下载的文件命名
                //         link.download = "label_user_" + this.username + "_" + this.sex + "_" + this.age +
                //             "_" + this.academic + "_" + this.major + "_" + this.dataStudy + "_" + this
                //                 .figureStudy + "_" + this.analysisStudy + ".csv";
                //         document.body.appendChild(link);
                //         link.click();
                //         document.body.removeChild(link);
                // }
                //     //进入下一案例，则结束时间
                //     this.endTime = Date.now();
                //     clearInterval(that.flash);   //关闭刷新
                //     this.caseList[this.activeCase]['time'] = (this.endTime - this.startTime)/1000;
                //     // console.log((this.endTime - this.startTime)/1000)
                //     // console.log("123123",this.caseList)
                //     //再次询问
                //     if (confirm("准备好进行下一个案例了吗？")) {
                //         this.activeCase++;
                //         this.loadJson();
                //     }
                // }
                if (this.activeCase + 1 >= this.caseList.length) {
                    //结束实验，则结束最后一个案例时间
                    // this.endTime = Date.now();
                    clearInterval(that.flash);   //关闭刷新
                    this.caseList[this.activeCase]['time'] = (this.endTime - this.startTime)/1000;

                    if (confirm("实验结束，确定要退出系统？")) {
                        //保存信息
                        let casedata = this.caseList;

                        let localCaselist = []
                        // 处理数据为csv的格式
                        let csvString = ""
                        csvString += "字母" + ',' + "遮挡方向" + ',' + "重叠比例" + ',' + "实验者视感" + ',' +
                            "确信程度" + ','+ "耗时" + ',' + "是否正确"
                        csvString += '\r\n'
                        casedata.map(item => {
                            let row = {
                                'letter': item.letter,
                                'direction': item.direction,
                                'givenPercent': item.givenPercent,
                            }
                            localCaselist.push(row) //caseList里面的案例顺序以答案为准

                            csvString += item.letter + ',' + item.direction + ',' + item.givenPercent +
                                ',' + item.input + ',' + item.confidence + ',' + item.time + ',' + item.flag
                            csvString += '\r\n'
                        })
                        //storage只能存储字符串的数据，对于JS中常用的数组或对象不能直接存储
                        //可以通过JSON对象提供的parse和stringify将其他数据类型转化成字符串，再存储到storage中
                        let str = JSON.stringify(localCaselist);
                        localStorage.setItem("localCaselist", str);

                        // 保存为csv文件并添加下载按钮
                        csvString = "data:application/csv," + encodeURIComponent(csvString);
                        let link = document.createElement('a');
                        link.href = csvString;
                        //对下载的文件命名
                        link.download = "label_user_" + this.username + "_" + this.sex + "_" + this.age +
                            "_" + this.academic + "_" + this.major + "_" + this.dataStudy + "_" + this
                            .figureStudy + "_" + this.analysisStudy + ".csv";

                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        //跳转到反馈页面
                        window.location.href = 'end.html'
                    }
                }
                else {
                    //进入下一案例，则结束时间
                    // this.endTime = Date.now();
                    clearInterval(that.flash);   //关闭刷新
                    console.log(this.endTime)
                    console.log(this.startTime)
                    this.caseList[this.activeCase]['time'] = (this.endTime - this.startTime)/1000;
                    if (confirm("准备好进行下一个案例了吗？")) {
                        this.activeCase++;
                        this.loadJson();
                    }
                }

            },


            /**
             * 获取已经被占用的像素坐标
             */
            get_global: function (ctx) {
                let arr=[];
                //var sum=0;
                let image_data=ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height);
                ctx.imageSmoothingEnabled = true;
                ctx.webkitImageSmoothingEnabled = true;
                ctx.mozImageSmoothingEnabled = true;
                ctx.willReadFrequently = true;
                let data = image_data.data;
                for(let j=0;j<ctx.canvas.height;j++){
                    for(let i=0;i<ctx.canvas.width;i++){
                        if(data[(j*ctx.canvas.width+i)*4+3]!==0){
                            arr.push({x:j,y:i,val:[data[(j*ctx.canvas.width+i)*4],data[(j*ctx.canvas.width+i)*4+1],
                                    data[(j*ctx.canvas.width+i)*4+2],data[(j*ctx.canvas.width+i)*4+3]]});
                        }
                    }
                }
                return arr;
            },
            /**
             * 获取已经被占用的像素坐标
             */
            get_change2: function(arr1,arr2) {
                let sum3=0;
                for(let i=0;i<arr1.length;i++){
                    for(let j=0;j<arr2.length;j++){
                        if(arr1[i].x===arr2[j].x){
                            if(arr1[i].y===arr2[j].y){
                                sum3+=1;
                            }
                        }
                    }
                }
                return sum3/arr1.length;
            },
            /**
             * 求白色矩形块遮挡字母像素占被遮挡字母像素的百分比
             */
            liner_rect_overlap: function (ctx,start_x,start_y,width,height,
                                          rect_width,rect_height,direction,percent,letter_pixel,slope){
                //求白色矩形块遮挡字母像素占被遮挡字母像素的百分比
                let offCanvas=document.createElement("canvas");
                offCanvas.width=200;
                offCanvas.height=100;
                let offContext = offCanvas.getContext('2d', { willReadFrequently: true });
                let temp3=direction;
                offContext.fillStyle = 'white';
                let percent1 = 0;
                if(temp3===-1){
                    offContext.clearRect(0,0,200,100);
                }
                else if(temp3===1){
                    //初始状态不要遮挡
                    offContext.fillRect(start_x+width+5,start_y-height/2-rect_height/2,rect_width,rect_height);
                    let rect_pixel=this.get_global(offContext);
                    percent1=this.get_change2(letter_pixel,rect_pixel);
                    if (percent1!==0){
                        console.log("警告警告");
                    }
                    let x=0;
                    while(percent1<percent){
                        x+=1;
                        offContext.clearRect(0,0,200,100);
                        offContext.fillRect(start_x+width-x+5,start_y-height/2-rect_height/2,rect_width,rect_height);
                        rect_pixel=this.get_global(offContext);
                        percent1=this.get_change2(letter_pixel,rect_pixel);
                        if(x>rect_width+5){
                            break;
                        }
                    }
                    ctx.drawImage(offCanvas,0,0);
                }
                else if(temp3===2){
                    offContext.fillRect(start_x+width,start_y-height-rect_height,rect_width,rect_height);
                    let rect_pixel=this.get_global(offContext);
                    percent1=this.get_change2(letter_pixel,rect_pixel);
                    if (percent1!==0){
                        console.log("警告警告");
                    }
                    //在该状态空间内移动
                    for(let x=0;x<=width;x++){
                        for(let y=0;y<=x*slope;y++){
                            offContext.clearRect(0,0,200,100);
                            offContext.fillRect(start_x+width-x,start_y-height-rect_height+y,rect_width,rect_height);
                            rect_pixel=this.get_global(offContext);
                            percent1=this.get_change2(letter_pixel,rect_pixel);
                            console.log(percent1)
                            if (percent1>=percent){
                                break;
                            }
                        }
                        if(percent1>=percent){
                            break;
                        }
                    }
                    ctx.drawImage(offCanvas,0,0);
                }
                else if(temp3===3){
                    offContext.fillRect(start_x+width/2-rect_width/2,start_y-height-rect_height-5,rect_width,rect_height);
                    let rect_pixel=this.get_global(offContext);
                    percent1=this.get_change2(letter_pixel,rect_pixel);
                    if (percent1!==0){
                        console.log("警告警告");
                    }
                    let x=0;
                    while(percent1<percent){
                        x+=1;
                        offContext.clearRect(0,0,200,100);
                        offContext.fillRect(start_x+width/2-rect_width/2,start_y-height-rect_height+x-5,rect_width,rect_height);
                        rect_pixel=this.get_global(offContext);
                        percent1=this.get_change2(letter_pixel,rect_pixel);
                        if(x>rect_height+5){
                            break;
                        }
                    }
                    ctx.drawImage(offCanvas,0,0);
                }
                else if(temp3===4){
                    offContext.fillRect(start_x-rect_width,start_y-height-rect_height,rect_width,rect_height);
                    let rect_pixel=this.get_global(offContext);
                    percent1=this.get_change2(letter_pixel,rect_pixel);
                    if (percent1!==0){
                        console.log("警告警告");
                    }
                    //在该状态空间内移动
                    for(let x=0;x<=width;x++){
                        for(let y=0;y<=x*slope;y++){
                            offContext.clearRect(0,0,200,100);
                            offContext.fillRect(start_x-rect_width+x,start_y-height-rect_height+y,rect_width,rect_height);
                            rect_pixel=this.get_global(offContext);
                            percent1=this.get_change2(letter_pixel,rect_pixel);
                            if (percent1>=percent){
                                break;
                            }
                        }
                        if(percent1>=percent){
                            break;
                        }
                    }
                    ctx.drawImage(offCanvas,0,0);
                }
                else if(temp3===5){
                    offContext.fillRect(start_x-rect_width-5,start_y-rect_height/2-height/2,rect_width,rect_height);
                    let rect_pixel=this.get_global(offContext);
                    percent1=this.get_change2(letter_pixel,rect_pixel);
                    let x=0;
                    if (percent1!==0){
                        console.log("警告警告");
                    }
                    while(percent1<percent){
                        x+=1;
                        offContext.clearRect(0,0,200,100);
                        offContext.fillRect(start_x-rect_width-5+x,start_y-rect_height/2-height/2,rect_width,rect_height);
                        rect_pixel=this.get_global(offContext);
                        percent1=this.get_change2(letter_pixel,rect_pixel);
                        if(x>rect_width+5){
                            break;
                        }
                    }
                    ctx.drawImage(offCanvas,0,0);
                }
                else if(temp3===6){
                    offContext.fillRect(start_x-rect_width,start_y,rect_width,rect_height);
                    let rect_pixel=this.get_global(offContext);
                    percent1=this.get_change2(letter_pixel,rect_pixel);

                    //在该状态空间内移动
                    for(let x=0;x<=width;x++){
                        for(let y=0;y<=x*slope;y++){
                            offContext.clearRect(0,0,200,100);
                            offContext.fillRect(start_x-rect_width+x,start_y-y,rect_width,rect_height);
                            rect_pixel=this.get_global(offContext);
                            percent1=this.get_change2(letter_pixel,rect_pixel);
                            if (percent1>=percent){
                                break;
                            }
                        }
                        if(percent1>=percent){
                            break;
                        }
                    }
                    ctx.drawImage(offCanvas,0,0);
                }
                else if(temp3===7){
                    offContext.fillRect(start_x+width/2-rect_width/2,start_y+5,rect_width,rect_height);
                    let rect_pixel=this.get_global(offContext);
                    percent1=this.get_change2(letter_pixel,rect_pixel);
                    if (percent1!==0){
                        console.log("警告警告");
                    }
                    let x=0;
                    while(percent1<percent){
                        x+=1;
                        offContext.clearRect(0,0,200,100);
                        offContext.fillRect(start_x+width/2-rect_width/2,start_y+5-x,rect_width,rect_height);
                        rect_pixel=this.get_global(offContext);
                        percent1=this.get_change2(letter_pixel,rect_pixel);
                        if(x>rect_height+5){
                            break;
                        }
                    }
                    ctx.drawImage(offCanvas,0,0);
                }
                else if(temp3===8){
                    offContext.fillRect(start_x+width,start_y,rect_width,rect_height);
                    let rect_pixel=this.get_global(offContext);
                    percent1=this.get_change2(letter_pixel,rect_pixel);
                    if (percent1!==0){
                        console.log("警告警告");
                    }
                    for(let x=0;x<=width;++x){
                        for(let y=0;y<=x*slope;y++){
                            offContext.clearRect(0,0,200,100);
                            offContext.fillRect(start_x+width-x,start_y-y,rect_width,rect_height);
                            rect_pixel=this.get_global(offContext);
                            percent1=this.get_change2(letter_pixel,rect_pixel);
                            if (percent1>=percent){
                                break;
                            }
                        }
                        if (percent1>=percent){
                            break;
                        }
                    }
                    ctx.drawImage(offCanvas,0,0);
                }
                return percent1;
            },
            /**
             * 计算文本的宽度和高度
             */
            getTextMetric: function (text) {
                const canvas=document.createElement('canvas');
                const context=canvas.getContext('2d', { willReadFrequently: true });
                context.font='16px Times New Roman';
                let me2=context.measureText(text);
                let word_h=Math.abs(me2.actualBoundingBoxAscent) + Math.abs(me2.actualBoundingBoxDescent);
                let word_w=Math.abs(me2.actualBoundingBoxLeft) + Math.abs(me2.actualBoundingBoxRight);
                return [Math.ceil(word_w),Math.ceil(word_h)];
            },
            /**
             * 找到a~z中最大的宽和高作为遮挡用的矩形块的宽和高
             */
            getMaxWH: function() {
                const letterList=['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',
                    'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
                let max_wh=[0,0];
                for(let i=0; i<letterList.length; i++){
                    let w_h=this.getTextMetric(letterList[i]);
                    max_wh[0]=Math.max(max_wh[0],w_h[0]);
                    max_wh[1]=Math.max(max_wh[1],w_h[1]);
                }

                return [Math.ceil(max_wh[1]),Math.ceil(max_wh[1])];
            },
            /**
             * 获取26*8*11个数据
             */
            getData: function() {
                const letterList=['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
                    'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
                //生成11个随机等级
                const cover_level=[0.01,0.11,0.21,0.31,0.41,0.51,0.61,0.71,0.81];
                let letterArr = [];//存储JSON数据
                for(let i=0;i<letterList.length;i++){
                    //临时对象
                    let obj={ letter: 'a', direction: -1, givenPercent: 0};
                    obj.letter=letterList[i];//定义字母
                    letterArr.push(obj);
                }
                for(let i=0;i<letterList.length;i++){
                    for(let j=1;j<=8;j++){
                        for(let k=0; k<cover_level.length;k++){
                            //临时对象
                            let obj={ word: 'a', direction: 1, givenPercent: 0};
                            obj.letter=letterList[i];//定义字母
                            obj.direction=j;//定义方向
                            // obj.givenPercent=Math.random() * 0.09 + cover_level[k];
                            obj.givenPercent=cover_level[k];
                            letterArr.push(obj);//push的只是引用
                        }
                    }
                }
                return letterArr;
            },
        }
    })
</script>

</html>
